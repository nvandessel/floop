<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>floop — Behavior Graph</title>
<style>
  /* Catppuccin Mocha palette */
  :root {
    --base: #1e1e2e;
    --surface0: #313244;
    --surface1: #45475a;
    --surface2: #585b70;
    --text: #cdd6f4;
    --subtext0: #a6adc8;
    --subtext1: #bac2de;
    --blue: #89b4fa;
    --red: #f38ba8;
    --green: #a6e3a1;
    --yellow: #f9e2af;
    --mauve: #cba6f7;
    --overlay0: #6c7086;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--base);
    color: var(--text);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
  }

  #graph { width: 100vw; height: 100vh; }

  /* Tooltip */
  #tooltip {
    position: absolute;
    display: none;
    background: var(--surface0);
    border: 1px solid var(--surface2);
    border-radius: 6px;
    padding: 8px 12px;
    font-size: 12px;
    line-height: 1.5;
    pointer-events: none;
    z-index: 100;
    max-width: 300px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  }
  #tooltip .tt-name { font-weight: 600; color: var(--text); margin-bottom: 4px; }
  #tooltip .tt-kind { color: var(--subtext0); font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; }
  #tooltip .tt-meta { color: var(--subtext1); font-size: 11px; margin-top: 4px; }

  /* Detail panel */
  #detail-panel {
    position: absolute;
    top: 0;
    right: -380px;
    width: 360px;
    height: 100vh;
    background: var(--surface0);
    border-left: 1px solid var(--surface2);
    padding: 20px;
    overflow-y: auto;
    transition: right 0.3s ease;
    z-index: 200;
    box-shadow: -4px 0 16px rgba(0,0,0,0.3);
  }
  #detail-panel.open { right: 0; }
  #detail-panel .dp-close {
    position: absolute;
    top: 12px;
    right: 12px;
    background: none;
    border: none;
    color: var(--subtext0);
    font-size: 18px;
    cursor: pointer;
  }
  #detail-panel .dp-close:hover { color: var(--text); }
  #detail-panel h2 { font-size: 16px; margin-bottom: 16px; color: var(--text); padding-right: 24px; word-break: break-word; }
  #detail-panel .dp-section { margin-bottom: 12px; }
  #detail-panel .dp-label { font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--subtext0); margin-bottom: 2px; }
  #detail-panel .dp-value { font-size: 13px; color: var(--text); }
  #detail-panel .dp-bar { height: 4px; background: var(--surface2); border-radius: 2px; margin-top: 4px; }
  #detail-panel .dp-bar-fill { height: 100%; border-radius: 2px; }

  /* Legend */
  #legend {
    position: absolute;
    bottom: 16px;
    left: 16px;
    background: var(--surface0);
    border: 1px solid var(--surface2);
    border-radius: 8px;
    padding: 12px 16px;
    font-size: 11px;
    z-index: 50;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  }
  #legend h3 { font-size: 12px; margin-bottom: 8px; color: var(--subtext1); font-weight: 500; }
  .legend-row { display: flex; align-items: center; gap: 6px; margin-bottom: 4px; }
  .legend-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
  .legend-line { width: 20px; height: 0; flex-shrink: 0; }
  .legend-label { color: var(--subtext0); }

  /* Stats bar */
  #stats {
    position: absolute;
    top: 16px;
    left: 16px;
    background: var(--surface0);
    border: 1px solid var(--surface2);
    border-radius: 8px;
    padding: 8px 14px;
    font-size: 12px;
    color: var(--subtext0);
    z-index: 50;
  }
  #stats span { color: var(--text); font-weight: 500; }

  /* Scope filter toggle */
  #scope-filter {
    position: absolute;
    top: 16px;
    right: 16px;
    display: flex;
    background: var(--surface0);
    border: 1px solid var(--surface2);
    border-radius: 8px;
    overflow: hidden;
    z-index: 50;
  }
  #scope-filter button {
    background: none;
    border: none;
    color: var(--subtext0);
    font-size: 12px;
    font-family: inherit;
    padding: 6px 14px;
    cursor: pointer;
    transition: background 0.15s, color 0.15s;
    border-right: 1px solid var(--surface2);
  }
  #scope-filter button:last-child { border-right: none; }
  #scope-filter button:hover { background: var(--surface1); color: var(--text); }
  #scope-filter button.active { background: var(--blue); color: var(--base); font-weight: 600; }

  /* Scope badge in detail panel */
  .dp-scope-badge {
    display: inline-block;
    font-size: 11px;
    font-weight: 600;
    padding: 2px 8px;
    border-radius: 4px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .dp-scope-badge.scope-local { background: rgba(166,227,161,0.2); color: var(--green); }
  .dp-scope-badge.scope-global { background: rgba(137,180,250,0.2); color: var(--blue); }
  .dp-scope-badge.scope-both { background: rgba(203,166,247,0.2); color: var(--mauve); }
  .dp-scope-badge.scope-unknown { background: rgba(108,112,134,0.2); color: var(--overlay0); }
</style>
</head>
<body>
<div id="graph"></div>

<div id="tooltip">
  <div class="tt-name"></div>
  <div class="tt-kind"></div>
  <div class="tt-meta"></div>
</div>

<div id="detail-panel">
  <button class="dp-close" onclick="closePanel()">&times;</button>
  <h2 id="dp-name"></h2>
  <div id="dp-content"></div>
</div>

<div id="stats">
  <span id="stat-nodes">0</span> nodes &middot; <span id="stat-edges">0</span> edges
</div>

<div id="scope-filter">
  <button class="active" data-scope="all">All</button>
  <button data-scope="local">Local</button>
  <button data-scope="global">Global</button>
</div>

<div id="legend">
  <h3>Node Types</h3>
  <div class="legend-row"><div class="legend-dot" style="background:#89b4fa"></div><span class="legend-label">directive</span></div>
  <div class="legend-row"><div class="legend-dot" style="background:#f38ba8"></div><span class="legend-label">constraint</span></div>
  <div class="legend-row"><div class="legend-dot" style="background:#a6e3a1"></div><span class="legend-label">procedure</span></div>
  <div class="legend-row"><div class="legend-dot" style="background:#f9e2af"></div><span class="legend-label">preference</span></div>
  <h3 style="margin-top:10px">Edge Types</h3>
  <div class="legend-row"><svg width="20" height="10"><line x1="0" y1="5" x2="20" y2="5" stroke="#6c7086" stroke-width="1.5"/></svg><span class="legend-label">requires</span></div>
  <div class="legend-row"><svg width="20" height="10"><line x1="0" y1="5" x2="20" y2="5" stroke="#6c7086" stroke-width="3"/></svg><span class="legend-label">overrides</span></div>
  <div class="legend-row"><svg width="20" height="10"><line x1="0" y1="5" x2="20" y2="5" stroke="#6c7086" stroke-width="1.5" stroke-dasharray="4,3"/></svg><span class="legend-label">conflicts</span></div>
  <div class="legend-row"><svg width="20" height="10"><line x1="0" y1="5" x2="20" y2="5" stroke="#6c7086" stroke-width="1" stroke-dasharray="2,2"/></svg><span class="legend-label">similar-to</span></div>
  <div class="legend-row"><svg width="20" height="10"><line x1="0" y1="5" x2="20" y2="5" stroke="#6c7086" stroke-width="2"/></svg><span class="legend-label">learned-from</span></div>
  <div class="legend-row"><svg width="20" height="10"><line x1="0" y1="5" x2="20" y2="5" stroke="#cba6f7" stroke-width="1.5" stroke-dasharray="6,3"/></svg><span class="legend-label">merged-into</span></div>
  <h3 style="margin-top:10px">Scope (ring)</h3>
  <div class="legend-row"><svg width="12" height="12"><circle cx="6" cy="6" r="4.5" fill="none" stroke="#a6e3a1" stroke-width="1.5"/></svg><span class="legend-label">local</span></div>
  <div class="legend-row"><svg width="12" height="12"><circle cx="6" cy="6" r="4.5" fill="none" stroke="#89b4fa" stroke-width="1.5"/></svg><span class="legend-label">global</span></div>
  <div class="legend-row"><svg width="12" height="12"><circle cx="6" cy="6" r="4.5" fill="none" stroke="#cba6f7" stroke-width="1.5"/></svg><span class="legend-label">both</span></div>
</div>

<script src="{{.ForceGraphSrc}}"></script>
<script>
(function() {
  'use strict';

  // Graph data injected by Go template
  var graphData = {{.GraphJSON}};

  // Color palette (Catppuccin Mocha)
  var kindColors = {
    'directive':  '#89b4fa',
    'constraint': '#f38ba8',
    'procedure':  '#a6e3a1',
    'preference': '#f9e2af'
  };
  var defaultColor = '#6c7086';

  // Edge styling
  var edgeWidth = {
    'requires': 2,
    'overrides': 3,
    'conflicts': 2,
    'similar-to': 1.2,
    'learned-from': 2.5,
    'merged-into': 1.5
  };
  var edgeDash = {
    'conflicts': [4, 3],
    'similar-to': [2, 2],
    'merged-into': [6, 3]
  };
  var edgeColors = {
    'requires': 'rgba(137,180,250,0.5)',
    'overrides': 'rgba(243,139,168,0.5)',
    'conflicts': 'rgba(243,139,168,0.6)',
    'similar-to': 'rgba(166,173,200,0.35)',
    'learned-from': 'rgba(166,227,161,0.5)',
    'merged-into': 'rgba(203,166,247,0.4)'
  };
  var defaultEdgeColor = 'rgba(147,153,178,0.45)';

  // Scope ring colors (Catppuccin Mocha)
  var scopeRingColors = {
    'local':   '#a6e3a1',
    'global':  '#89b4fa',
    'both':    '#cba6f7',
    'unknown': '#6c7086'
  };

  // Build node ID set and filter dangling edges
  var nodeIds = {};
  (graphData.nodes || []).forEach(function(n) { nodeIds[n.id] = true; });
  var validEdges = (graphData.edges || []).filter(function(e) {
    return nodeIds[e.source] && nodeIds[e.target];
  });

  // Focus mode state
  var focusedNodeId = null;
  var focusDistances = null; // nodeId -> hop distance from focused node

  // Build bidirectional adjacency map for BFS
  function buildAdjacencyMap(links) {
    var adj = {};
    links.forEach(function(e) {
      var src = e.source.id || e.source;
      var tgt = e.target.id || e.target;
      if (!adj[src]) adj[src] = [];
      if (!adj[tgt]) adj[tgt] = [];
      adj[src].push(tgt);
      adj[tgt].push(src);
    });
    return adj;
  }

  function calculateFocusDistances(focusId, adj) {
    var distances = {};
    distances[focusId] = 0;
    var queue = [focusId];
    var head = 0;
    while (head < queue.length) {
      var cur = queue[head++];
      var neighbors = adj[cur] || [];
      for (var i = 0; i < neighbors.length; i++) {
        if (distances[neighbors[i]] === undefined) {
          distances[neighbors[i]] = distances[cur] + 1;
          queue.push(neighbors[i]);
        }
      }
    }
    return distances;
  }

  function getNodeOpacity(nodeId) {
    if (!focusedNodeId || !focusDistances) return 1.0;
    var d = focusDistances[nodeId];
    if (d === undefined) return 0.12;
    if (d <= 1) return 1.0;
    if (d === 2) return 0.4;
    return 0.12;
  }

  function getLinkOpacity(link) {
    if (!focusedNodeId || !focusDistances) return null; // null = use default
    var src = link.source.id || link.source;
    var tgt = link.target.id || link.target;
    var sd = focusDistances[src], td = focusDistances[tgt];
    if (sd !== undefined && td !== undefined && sd <= 2 && td <= 2) return null;
    return 0.08;
  }

  var adjacencyMap = buildAdjacencyMap(validEdges);

  // Build degree map for node sizing
  var degree = {};
  (graphData.nodes || []).forEach(function(n) { degree[n.id] = 0; });
  validEdges.forEach(function(e) {
    degree[e.source] = (degree[e.source] || 0) + 1;
    degree[e.target] = (degree[e.target] || 0) + 1;
  });

  // Compute node sizes: pagerank * 8 + degree * 0.3 + 1, clamped [1, 10]
  (graphData.nodes || []).forEach(function(n) {
    var pr = n.pagerank || 0;
    var deg = degree[n.id] || 0;
    n.val = Math.min(10, Math.max(1, pr * 8 + deg * 0.3 + 1));
  });

  // Update stats
  document.getElementById('stat-nodes').textContent = (graphData.nodes || []).length;
  document.getElementById('stat-edges').textContent = validEdges.length;

  // Tooltip
  var tooltip = document.getElementById('tooltip');

  // Detail panel
  var panel = document.getElementById('detail-panel');

  // Create force graph (exposed on window for testing)
  var graph = window.__graph = ForceGraph()(document.getElementById('graph'))
    .graphData({
      nodes: graphData.nodes || [],
      links: validEdges.map(function(e) {
        return { source: e.source, target: e.target, kind: e.kind, weight: e.weight };
      })
    })
    .backgroundColor('#1e1e2e')
    .nodeRelSize(4)
    .nodeVal(function(n) { return n.val; })
    .nodeColor(function(n) { return kindColors[n.kind] || defaultColor; })
    .nodeCanvasObject(function(node, ctx, globalScale) {
      var r = Math.sqrt(node.val || 1) * 2.5;
      var color = kindColors[node.kind] || defaultColor;

      // Apply focus mode opacity
      ctx.globalAlpha = getNodeOpacity(node.id);

      // Scope ring (drawn behind the node fill)
      var ringColor = scopeRingColors[node.scope] || scopeRingColors['unknown'];
      ctx.beginPath();
      ctx.arc(node.x, node.y, r + 1.5, 0, 2 * Math.PI);
      ctx.strokeStyle = ringColor;
      ctx.lineWidth = 1.2;
      ctx.stroke();

      // Filled circle with subtle stroke
      ctx.beginPath();
      ctx.arc(node.x, node.y, r, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 0.6;
      ctx.stroke();

      // Glow ring for focused node
      if (node.id === focusedNodeId) {
        ctx.beginPath();
        ctx.arc(node.x, node.y, r + 3, 0, 2 * Math.PI);
        ctx.strokeStyle = 'rgba(137,180,250,0.6)';
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Reset alpha for labels (keep readable)
      ctx.globalAlpha = 1.0;

      // Labels appear when zoomed in
      if (globalScale > 5) {
        var label = node.name || node.id;
        if (label.length > 30) label = label.substring(0, 27) + '...';
        var fontSize = 10 / globalScale;
        ctx.font = fontSize + 'px -apple-system, BlinkMacSystemFont, monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillStyle = 'rgba(205,214,244,0.7)';
        ctx.fillText(label, node.x, node.y + r + 2);
      }
    })
    .nodePointerAreaPaint(function(node, color, ctx) {
      var r = Math.sqrt(node.val || 1) * 2.5;
      ctx.beginPath();
      ctx.arc(node.x, node.y, r + 4, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
    })
    .enableNodeDrag(true)
    .autoPauseRedraw(false)
    .linkColor(function(l) {
      var base = edgeColors[l.kind] || defaultEdgeColor;
      var lo = getLinkOpacity(l);
      if (lo !== null) {
        return base.replace(/[\d.]+\)$/, lo + ')');
      }
      return base;
    })
    .linkWidth(function(l) {
      var w = edgeWidth[l.kind] || 1;
      if (getLinkOpacity(l) !== null) w *= 0.5;
      return w;
    })
    .linkLineDash(function(l) { return edgeDash[l.kind] || null; })
    .linkDirectionalArrowLength(5)
    .linkDirectionalArrowRelPos(0.92)
    .linkDirectionalArrowColor(function(l) {
      var base = 'rgba(147,153,178,0.6)';
      var lo = getLinkOpacity(l);
      if (lo !== null) {
        return base.replace(/[\d.]+\)$/, lo + ')');
      }
      return base;
    })
    .d3AlphaDecay(0.02)
    .d3VelocityDecay(0.4)
    .warmupTicks(300)
    .cooldownTime(Infinity)
    .onNodeDragEnd(function(node) {
      // Release the node so it rejoins the simulation
      node.fx = undefined;
      node.fy = undefined;
    })
    .onNodeHover(function(node, prevNode) {
      document.body.style.cursor = node ? 'pointer' : 'default';
      if (node) {
        var tt = document.getElementById('tooltip');
        tt.querySelector('.tt-name').textContent = node.name || node.id;
        tt.querySelector('.tt-kind').textContent = node.kind || 'unknown';
        var meta = 'confidence: ' + (node.confidence || 0).toFixed(2);
        if (node.pagerank) meta += '  pagerank: ' + node.pagerank.toFixed(3);
        meta += '  scope: ' + (node.scope || 'unknown');
        tt.querySelector('.tt-meta').textContent = meta;
        tt.style.display = 'block';
      } else {
        tooltip.style.display = 'none';
      }
    })
    .onNodeClick(function(node) {
      graph.__nodeClickTime = Date.now();
      focusedNodeId = node.id;
      focusDistances = calculateFocusDistances(node.id, adjacencyMap);
      showDetail(node);
    })
    .onBackgroundClick(function() {
      // Ignore if a node was just clicked (force-graph fires both events)
      if (graph.__nodeClickTime && Date.now() - graph.__nodeClickTime < 200) return;
      focusedNodeId = null;
      focusDistances = null;
      closePanel();
    })
    .onEngineStop(function() {
      // Auto-fit once when simulation first settles, capped at zoom=1
      if (!graph.__fitted) {
        graph.__fitted = true;
        graph.zoomToFit(400, 200);
        // Cap zoom so we get an overview, not a close-up
        setTimeout(function() {
          var z = graph.zoom();
          if (z > 1) graph.zoom(1);
        }, 500);
      }
    });

  // d3-force tuning — moderate forces safe for interactive drag
  var nodeCount = (graphData.nodes || []).length;
  var chargeStrength = Math.max(-400, -150 - nodeCount * 1.5);

  graph.d3Force('charge')
    .strength(chargeStrength)
    .distanceMax(350);
  graph.d3Force('link').distance(80).strength(0.12);
  graph.d3Force('center').strength(0.1);

  // Gentle gravity: pulls each node toward origin so nothing drifts to infinity
  graph.d3Force('gravity', (function() {
    var strength = 0.04;
    var nodes;
    function force(alpha) {
      for (var i = 0, n = nodes.length; i < n; i++) {
        nodes[i].vx -= nodes[i].x * strength * alpha;
        nodes[i].vy -= nodes[i].y * strength * alpha;
      }
    }
    force.initialize = function(_nodes) { nodes = _nodes; };
    return force;
  })());

  // Track mouse for tooltip positioning
  document.addEventListener('mousemove', function(e) {
    tooltip.style.left = (e.pageX + 12) + 'px';
    tooltip.style.top = (e.pageY - 10) + 'px';
  });

  // Fallback zoom-to-fit in case onEngineStop doesn't fire
  setTimeout(function() { graph.zoomToFit(400, 200); }, 3000);

  // --- Scope filtering ---
  var activeScope = 'all';

  function filterByScope(scope) {
    activeScope = scope;

    // Update button states
    var buttons = document.querySelectorAll('#scope-filter button');
    for (var i = 0; i < buttons.length; i++) {
      buttons[i].classList.toggle('active', buttons[i].getAttribute('data-scope') === scope);
    }

    // Filter nodes
    var filteredNodes;
    if (scope === 'all') {
      filteredNodes = (graphData.nodes || []).slice();
    } else {
      filteredNodes = (graphData.nodes || []).filter(function(n) {
        return n.scope === scope || n.scope === 'both';
      });
    }

    // Build visible node set
    var visibleIds = {};
    filteredNodes.forEach(function(n) { visibleIds[n.id] = true; });

    // Filter edges: both endpoints must be visible
    var allEdges = graphData.edges || [];
    var filteredEdges = allEdges.filter(function(e) {
      return visibleIds[e.source] && visibleIds[e.target];
    });

    // Recompute degree and node sizes for filtered set
    var filteredDegree = {};
    filteredNodes.forEach(function(n) { filteredDegree[n.id] = 0; });
    filteredEdges.forEach(function(e) {
      filteredDegree[e.source] = (filteredDegree[e.source] || 0) + 1;
      filteredDegree[e.target] = (filteredDegree[e.target] || 0) + 1;
    });
    filteredNodes.forEach(function(n) {
      var pr = n.pagerank || 0;
      var deg = filteredDegree[n.id] || 0;
      n.val = Math.min(10, Math.max(1, pr * 8 + deg * 0.3 + 1));
    });

    // Update the shared degree map for detail panel
    degree = filteredDegree;

    // Update stats
    document.getElementById('stat-nodes').textContent = filteredNodes.length;
    document.getElementById('stat-edges').textContent = filteredEdges.length;

    // Clear focus when scope changes
    focusedNodeId = null;
    focusDistances = null;
    adjacencyMap = buildAdjacencyMap(filteredEdges);

    // Re-render graph
    graph.graphData({
      nodes: filteredNodes,
      links: filteredEdges.map(function(e) {
        return { source: e.source, target: e.target, kind: e.kind, weight: e.weight };
      })
    });

    // Close detail panel when filter changes
    closePanel();

    // Re-fit after re-render
    setTimeout(function() { graph.zoomToFit(400, 80); }, 300);
  }

  // Bind scope filter buttons
  var scopeButtons = document.querySelectorAll('#scope-filter button');
  for (var i = 0; i < scopeButtons.length; i++) {
    scopeButtons[i].addEventListener('click', (function(btn) {
      return function() { filterByScope(btn.getAttribute('data-scope')); };
    })(scopeButtons[i]));
  }

  // Detail panel
  function showDetail(node) {
    document.getElementById('dp-name').textContent = node.name || node.id;
    var html = '';

    html += section('Kind', node.kind || 'unknown');

    var scopeVal = node.scope || 'unknown';
    var validScopes = { 'local': true, 'global': true, 'both': true, 'unknown': true };
    var scopeClass = 'scope-' + (validScopes[scopeVal] ? scopeVal : 'unknown');
    html += '<div class="dp-section"><div class="dp-label">Scope</div><div class="dp-value"><span class="dp-scope-badge ' + scopeClass + '">' + esc(scopeVal) + '</span></div></div>';

    html += barSection('Confidence', node.confidence || 0, kindColors[node.kind] || defaultColor);

    if (node.pagerank != null) {
      html += barSection('PageRank', node.pagerank, '#cba6f7');
    }

    var deg = degree[node.id] || 0;
    html += section('Connections', deg);

    // Show canonical content (the actual learning)
    if (node.canonical) {
      html += '<div class="dp-section"><div class="dp-label">Content</div><div class="dp-value" style="white-space:pre-wrap;font-size:12px;line-height:1.5;margin-top:4px;color:var(--subtext1)">' + esc(node.canonical) + '</div></div>';
    }

    html += '<div class="dp-section" style="margin-top:8px"><div class="dp-label">ID</div><div class="dp-value" style="font-size:10px;color:var(--overlay0);word-break:break-all">' + esc(node.id) + '</div></div>';

    document.getElementById('dp-content').innerHTML = html;
    panel.classList.add('open');
  }

  window.closePanel = function() {
    panel.classList.remove('open');
  };

  function section(label, value) {
    return '<div class="dp-section"><div class="dp-label">' + esc(label) + '</div><div class="dp-value">' + esc(String(value)) + '</div></div>';
  }

  function barSection(label, value, color) {
    var pct = Math.round(value * 100);
    return '<div class="dp-section"><div class="dp-label">' + esc(label) + '</div><div class="dp-value">' + pct + '%</div>' +
      '<div class="dp-bar"><div class="dp-bar-fill" style="width:' + pct + '%;background:' + color + '"></div></div></div>';
  }

  function esc(s) {
    var d = document.createElement('div');
    d.textContent = s;
    return d.innerHTML;
  }

  // Test helpers for focus mode
  window.__getFocusState = function() {
    return { focusedNodeId: focusedNodeId, distances: focusDistances };
  };
  window.__setFocusNode = function(nodeId) {
    focusedNodeId = nodeId;
    focusDistances = calculateFocusDistances(nodeId, adjacencyMap);
    return !!focusDistances;
  };
  window.__clearFocus = function() {
    focusedNodeId = null;
    focusDistances = null;
  };
})();
</script>
</body>
</html>
